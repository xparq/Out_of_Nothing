#### MSVC Jumpstart Makefile -- heavily customized from r12!
#### -> https://github.com/xparq/NMAKE-Jumpstart
####
#### BEWARE! Uses recursive NMAKE invocations, so update the macro below if
#### you rename this file:
THIS_MAKEFILE=Makefile.msvc
#
# NOTE: Macros can't be set on the NMAKE command line, only here, because the
#       recursion won't pass them along!... (But see custom_build_options!)
#
VERBOSE_CMD=0	# 0 .. 2. This one *can* be overriden from the cmdline! (see custom_build_options!)

#-----------------------------------------------------------------------------
# Config - Project layout
#-----------------------------------------------------------------------------
PRJ_NAME=$(SZ_APPNAME)
# Use the lower-case (processed) path macros here:
#main_lib=$(lib_dir)/$(PRJ_NAME)$(buildmode_suffix).lib
main_exe=$(exe_dir)/$(PRJ_NAME)$(buildmode_suffix).exe
# Main targets to build:
BUILD = $(main_lib) $(main_exe)

SRC_DIR=src
OUT_DIR=out
LIB_DIR=$(OUT_DIR)
EXE_DIR=$(OUT_DIR)
OBJ_DIR=$(OUT_DIR)/obj
CXX_MOD_IFC_DIR=$(OUT_DIR)
# Put (only) these into the lib (relative to SRC_DIR; leave it empty for "all"):
LIB_SRC_SUBDIR=

# Source (translation unit) basename filter (CMD shell glob pattern):
UNITS_PATTERN=*
# Ignore-filter on full-path source names -> NMAKE `filterout` pattern list syntax!
# Multiple patterns must be separated by spaces. Do NOT quote the list!
UNITS_NO_COMPILE_PATTERN=.off .tmp
# Ignore-filter on full-path source names -> `findstr` REGEX syntax!
# Multiple patterns must be separated by spaces. Do NOT quote the list!
UNITS_NO_AUTOLINK_PATTERN=main\.cpp \.off \.tmp sz[/\\]test
UNITS_NO_LIB_PATTERN=$(UNITS_NO_AUTOLINK_PATTERN)

#!! Kludge until I find out the correct way:
#!! Also done manually, coz no way to track the actual deps automatically...:
OON_CPP_MODULE_IFCS=\
	$(cxx_mod_ifc_dir)/Storage.ifc 

#!! Sigh... No header autodep... And no unified obj list either to use as a target! :-/
#!! Also, must use a fixed path (not necessary absolute, but definitely not just .),
#!! or else the filenames/patterns would be mistakenly applied to the current subdir,
#!! and MAKE would fail with "dunno how to make..."
#!! Also, must NOT use $(src_dir) $(src_dir_abspath) here, as those will also point
#!! to the current node of the source tree, not its root! :-o
OBJ_DEPS_manually=$(SRC_DIR)/*.hpp $(SRC_DIR)/cfg.h \
	$(SRC_DIR)/Model/*.hpp \
	$(SRC_DIR)/View/*.hpp \
	$(SRC_DIR)/UI/*.hpp \
	$(SRC_DIR)/UI/adapter/SFML/*.hpp \
#	$(SRC_DIR)/Platform/*.hpp \
	$(SRC_DIR)/adapter/SFML/*.hpp \
	$(SRC_DIR)/sz/*.hh \

#
# External dependencies:
#
EXT_INCLUDE_DIRS=
EXT_LIB_DIRS=
EXT_LIBS=\
	$(SFML_LIBROOT)/lib/$(sfml_and_deps_libs) \
	extern/sfw/lib/msvc/sfw$(_cflags_crt_linkmode)$(_buildmode_debug_file_suffix).lib \
	extern/zstd/msvc/zstd$(_cflags_crt_linkmode).lib \


#-----------------------------------------------------------------------------
# Config - Build options
#-----------------------------------------------------------------------------
# Build alternatives (override from the command-line, too, if needed):
DEBUG=0
CRT=dll
#!Sz: CRT=dll is always the case with the pre-built SFML libs, so not use changing it!
# Custom build options can also be added:
SFML=static
# Custom build options need to be passed along for recursion explicitly:
custom_build_options = SFML=$(SFML) VERBOSE_CMD=$(VERBOSE_CMD)

# Custom Tools:
#!Sz: Assuming being called from a script that has already set the path:
BB=@busybox
ECHO=@$(BB) echo
#! Unnecessary:
#MKDIR=$(BB) mkdir -p

# Comp. flags:
CFLAGS=-W4 -Iinclude
CXXFLAGS=-std:c++latest
# Note: C++ compilation would use $(CFLAGS), too.

# Output dir/file suffixes for build alternatives
# NOTE: Must differ from their "no ..." counterparts to avoid code (linking)
#       mismatches!
#!Sz: CRT=dll is always the case with the pre-built SFML libs, so not use changing it! (See also at CRT=...)
buildmode_crtdll_dir_suffix=.crtdll
buildmode_crtdll_file_suffix=-crtdll
buildmode_debug_dir_suffix=.DEBUG
buildmode_debug_file_suffix=-d

SFML_linkmode=$(SFML)
buildmode_dir_suffix=.sfml-$(SFML_linkmode)

#!-------------------------------------
#!Sz Other custom options for OON...
#!-------------------------------------
!if "$(SFML)" == "static"
CFLAGS=$(CFLAGS) -DSFML_STATIC
!endif
CXXFLAGS=-std:c++latest
# Note: C++ comp. commands would use $(CFLAGS), too! (!!Which may be stupid, and change later...!!)

# Adapt the various flavors of the SFML libs (as per the debug/link modes)...
sfml_libs_static=sfml-graphics-s.lib sfml-window-s.lib sfml-system-s.lib \
	sfml-audio-s.lib

sfml_libs_dll=sfml-graphics.lib sfml-window.lib sfml-system.lib \
	sfml-audio.lib

!if "$(SFML)" == "static"
sfml_libs=$(sfml_libs_static)
sfml_and_deps_libs=$(sfml_libs) opengl32.lib freetype.lib\
	ogg.lib vorbis.lib vorbisenc.lib vorbisfile.lib flac.lib openal32.lib \
	user32.lib kernel32.lib gdi32.lib winmm.lib advapi32.lib
!else if "$(SFML)" == "dll"
sfml_libs=$(sfml_libs_dll)
sfml_and_deps_libs=$(sfml_libs) opengl32.lib
!endif

!if defined(DEBUG) && $(DEBUG) == 1
sfml_libs=$(substi .lib,-d.lib,$(sfml_libs))
!endif

#=============================================================================
#                     NO EDITS NEEDED BELOW, NORMALLY...
#=============================================================================
obj_source_exts=cpp cxx cc c

#-----------------------------------------------------------------------------
# Show current processing stage...
#-----------------------------------------------------------------------------
!ifdef RECURSED_FOR_COMPILING
!if "$(DIR)" == ""
node=(main)
!else
node="$(DIR)"
!endif
!message Processing source dir: $(node)...
!endif

#-----------------------------------------------------------------------------
# Normalize the (prj-local) paths before potentially passing them to any of
# the arcane "DOS" commands only to make them choke on fwd. slashes!...
# + Also guard against accidental \ prefixes for empty dirs!
#   (Note: \ needs to be escaped here. Quoted paths are NOT handled here,
#   because those couldn't be used later anyway for appending subdirs, so
#   quoting is assumed to be handled at the last moment, when passing the
#   paths to commands!)
#-----------------------------------------------------------------------------
#! Not prefixdir=$(MAKEDIR), as most of these are subdirs!
#! Also: abspath'ed, so that user code doesn't have to worry about accidental
#! crosstalk between relative subdir macros like ($src_dir) across multiple
#! recursive runs for the indivirual source subdirs!... :-o
prefixdir=.
#! This is still too hamfisted if some were in fact ment to be absolute paths!
#! Anyway, at leat it's erring on the safe side.
src_dir         = $(prefixdir)\$(patsubst \\%,%,$(SRC_DIR:/=\))
out_dir         = $(prefixdir)\$(patsubst \\%,%,$(OUT_DIR:/=\))
lib_dir         = $(prefixdir)\$(patsubst \\%,%,$(LIB_DIR:/=\))
exe_dir         = $(prefixdir)\$(patsubst \\%,%,$(EXE_DIR:/=\))
obj_dir         = $(prefixdir)\$(patsubst \\%,%,$(OBJ_DIR:/=\))
cxx_mod_ifc_dir = $(prefixdir)\$(patsubst \\%,%,$(CXX_MOD_IFC_DIR:/=\))
!if "$(main_lib)" != ""
main_lib        = $(prefixdir)\$(patsubst \\%,%,$(main_lib:/=\))
!endif
!if "$(main_exe)" != ""
main_exe        = $(prefixdir)\$(patsubst \\%,%,$(main_exe:/=\))
!endif
# And this one is really a subdir, which will be prefixed internally with src_dir,
# so don't mess it up with the same adjustment, just normalize the slashes:
lib_src_subdir  = $(LIB_SRC_SUBDIR:/=\)

# Now, this one, OTOH, must be the normalized *full* path of the src root:
#   src_dir_abspath = $(MAKEDIR)\$(src_dir)
# -- used in the command blocks for abs->rel conversion (via direct path
# string replacement in the tree traversal loops), which needs to be as
# robust as possible! (And are still too brittle!...)
# Except...: if the path contains spaces, then it's considered a list,
# and each item would get separately normalized! (Quoting doesn't help! :-/ )
# So... Behold this shameless abomination of a workaround:
_SPACE_=$(subst x,,x x)
p=$(subst $(_SPACE_),<FAKE_SPACE>,$(MAKEDIR)\$(src_dir))
src_dir_abspath=$(subst <FAKE_SPACE>,$(_SPACE_),$(abspath $(p)))


#-----------------------------------------------------------------------------
# Set/adjust tool options (according to the config)...
#-----------------------------------------------------------------------------
# Preserve the original NMAKE flags & explicitly supported macros on recursion:
MAKE_CMD=$(MAKE) /nologo /$(MAKEFLAGS) /f $(THIS_MAKEFILE) DEBUG=$(DEBUG) CRT=$(CRT)

CFLAGS=-nologo -c $(CFLAGS)
CXXFLAGS=-EHsc $(CXXFLAGS)
!if "$(cxx_mod_ifc_dir)" != ""
CXXFLAGS=-ifcSearchDir $(cxx_mod_ifc_dir) $(CXXFLAGS)
!endif

#----------------------------
# Static/DLL CRT link mode
#------
!if "$(CRT)" == "static"
_cflags_crt_linkmode=-MT
!else if "$(CRT)" == "dll"
_cflags_crt_linkmode=-MD
!else
!error Unknown CRT link mode: $(CRT)!
!endif

#----------------------
# DEBUG/RELEASE mode
#------
cflags_debug_0=$(_cflags_crt_linkmode) -O2 -DNDEBUG
cflags_debug_1=$(_cflags_crt_linkmode)d -ZI -Od -Oy- -Ob0 -RTCsu -DDEBUG -Fd$(out_dir)/
	# The -O...s above are borrowed from Dr. Memory's README/Quick start.
	# -ZI enables edit-and-continue (but it only exists for Intel CPUs!).
linkflags_debug_0=
linkflags_debug_1=-debug -incremental -editandcontinue -ignore:4099

!if defined(DEBUG) && $(DEBUG) == 1
_cflags_debugmode=$(cflags_debug_1)
_linkflags_debugmode=$(linkflags_debug_1)
!else if $(DEBUG) == 0
_cflags_debugmode=$(cflags_debug_0)
_linkflags_debugmode=$(linkflags_debug_0)
!else
!error Unknown debug mode: $(DEBUG)!
!endif

CFLAGS=$(_cflags_debugmode) $(CFLAGS)
LINKFLAGS=$(_linkflags_debugmode) $(LINKFLAGS)


#---------------------------------------
# Update the INCLUDE & LIB env. vars for external tools
#------
!if "$(EXT_INCLUDE_DIRS)" != ""
!if [set INCLUDE=%INCLUDE%;$(EXT_INCLUDE_DIRS)]
!endif
!endif

!if "$(EXT_LIB_DIRS)" != ""
!if [set LIB=%LIB%;$(EXT_LIB_DIRS)]
!endif
!endif
# Or, alternatively:
#!if "$(EXT_LIB_DIRS)" != ""
#LINKFLAGS=$(LINKFLAGS) -libpath:$(EXT_LIB_DIRS)
#!endif

#-----------------------------------------------------------------------------
# Split the target tree across build alternatives...
#!! Would be nice to just split the root, but the libs and exes can be
#!! off the tree (for convenience & flexibility, e.g. differentiated by name
#!! suffixes etc.)... Which leaves us with dispatching the obj_dir instead
#!! -- and leaving the lib_dir and exe_dir totally ignored... :-/
#-----------------------------------------------------------------------------
# For the output dirs (currently only the obj. dir), and
# for the output files (currently the lib/exe files)
!if "$(CRT)" == "dll"
buildmode_dir_suffix=$(buildmode_dir_suffix)$(buildmode_crtdll_dir_suffix)
buildmode_file_suffix=$(buildmode_file_suffix)$(buildmode_crtdll_file_suffix)
!endif

!if "$(DEBUG)" == "1"
_buildmode_debug_file_suffix=$(buildmode_debug_file_suffix)
_buildmode_debug_dir_suffix=$(buildmode_debug_dir_suffix)
buildmode_dir_suffix=$(buildmode_dir_suffix)$(buildmode_debug_dir_suffix)
buildmode_file_suffix=$(buildmode_file_suffix)$(buildmode_debug_file_suffix)
!endif

obj_dir=$(obj_dir)$(buildmode_dir_suffix)

#-----------------------------------------------------------------------------
# Adjust paths for the inference rules, according to the current subdir-recursion
#-----------------------------------------------------------------------------
!if "$(DIR)" != ""
src_dir=$(src_dir)\$(DIR)
obj_dir=$(obj_dir)\$(DIR)
!endif

#=============================================================================
# Rules...
#=============================================================================

#!! SADLY...:
#!!
#!! We cannot construct the obj target list from the local sources (see compile_dir...), because
#!! NMAKE can only process wildcards on rule lines, where it's too late for this... :-/
#!!local_objs = $(no wildcard function!... )
#!!
#
# Trigger the inference rules by changed headers, too!...
#$(local_objs) : $(OBJ_DEPS_manually)

#-----------------------------------------------------------------------------
# Inference rules for .obj compilation...
# NOTE: The src & obj paths have been updated (see above) to match the subdir,
#       where the tree traversal (recursion) is currently at.
#-----------------------------------------------------------------------------
# Can't direclty add $(patsubst %,.%,$(obj_source_exts)) to .SUFFIXES, as that
# would trigger a syntax error! :-o Well, at least we have a descriptive name:
_compilable_src_exts_=$(patsubst %,.%,$(obj_source_exts))
.SUFFIXES:$(_compilable_src_exts_) .ixx .ifc .exe

#-----------------------------------------------------------------------------
!if "$(VERBOSE_CMD)" == "" || "$(VERBOSE_CMD)" == "0"
_mute=@
!endif
{$(src_dir)}.c{$(obj_dir)}.obj::
	$(_mute)$(CC) $(CFLAGS) -Fo$(obj_dir)\ $<

{$(src_dir)}.cpp{$(obj_dir)}.obj::
	$(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -Fo$(obj_dir)\ $<
{$(src_dir)}.cxx{$(obj_dir)}.obj::
	$(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -Fo$(obj_dir)\ $<
{$(src_dir)}.cc{$(obj_dir)}.obj::
	$(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -Fo$(obj_dir)\ $<

#!!?? This is probably not the way to compile mod. ifcs!...:
{$(src_dir)}.ixx{$(cxx_mod_ifc_dir)}.ifc::
	$(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -ifcOutput $(cxx_mod_ifc_dir)\ -Fo$(obj_dir)\ $<


#!message !! before treewaalk: abspath == $(src_dir_abspath), includes: $(OBJ_DEPS_manually)

#-----------------------------------------------------------------------------
# Default target - walk through the src tree dir-by-dir & compile all the
#                  sources, plus do an initial & a final wrapping round...
#-----------------------------------------------------------------------------
traverse_src_tree: init
	@cmd /v:on /c <<$(out_dir)\treewalk.cmd
	@echo off
	rem !!The make cmd. below fails to run without the extra shell! :-o
	rem !!Also -> #8 why the env. var here can't be called just "make"!... ;)
	set "_make_=cmd /c $(MAKE_CMD)"
	:: echo $(src_dir)
	:: echo !src_dir_abspath!
	rem Do the root level first (preps + top-level sources)...
	rem (Note: naming a (different) target would avoid inf. recursion!)
	set _dir_=$(src_dir)
        for %%x in ($(obj_source_exts)) do (
		if "$(VERBOSE_CMD)" GEQ "2" echo [!_dir_!/*.%%x]
		if "$(VERBOSE_CMD)" GEQ "2" echo if exist "$(src_dir)\*.%%x" echo [-^> !_make_! /c compiling SRC_EXT_=%%x $(custom_build_options)]
		                                 if exist "$(src_dir)\*.%%x"           !_make_! /c compiling SRC_EXT_=%%x $(custom_build_options)
		if errorlevel 1 exit -1
	)
	rem Scan the rest of the source tree for sources...
	for /f "delims=" %%d in ('dir /s /b /a:d "$(src_dir_abspath)"') do (
		rem It's *vital* to use a local name here, not `dir` (== $(DIR)!!!):
		set "_dir_=%%d"

		echo !_dir_! | findstr /L "$(UNITS_NO_COMPILE_PATTERN)" > nul
		if not errorlevel 1 (
			if "$(VERBOSE_CMD)" GEQ "1" echo - EXCLUDE DIR: !_dir_!
		) else (
			set "_dir_=!_dir_:$(src_dir_abspath)\=!"
			for %%x in ($(obj_source_exts)) do (
				if "$(VERBOSE_CMD)" GEQ "2" echo [!_dir_!/*.%%x]
				if "$(VERBOSE_CMD)" GEQ "2" if exist "%%d\*.%%x" echo [-^> !_make_! /c compiling DIR=!_dir_! SRC_EXT_=%%x $(custom_build_options)]
				rem  ... !_make_! ... "DIR=!_dir_!" would FAIL! if the NMAKE path has spaces! :-ooo
				rem See #224!
				                            if exist "%%d\*.%%x"           !_make_! /c compiling DIR=!_dir_! SRC_EXT_=%%x $(custom_build_options)
				if errorlevel 1 exit -1
			)
		)
	)
	!_make_! RECURSED_FOR_FINISHING=1 $(custom_build_options) finish
<<keep
#! '
#! This ' above is just to help the FAR Editor's syntax-highlighting to balance
#! a prev. one... :-o :) (Find it, understand why it's all of natural, problematic,
#! and fortunate, and appreciate this little gem like the interesting corpse
#! of a poor little rare animal on a forest hike. :) )

#-----------------------------------------------------------------------------
# Workflow Control Rules
#-----------------------------------------------------------------------------

# This rule is implicitly selected as the default target, only on the first run:
init: mk_main_target_dirs compile_mod_ifcs mk_mainlib_objdep_inc mk_mainexe_objdep_inc

# This rule is explicitly selected on the command-line of recursive calls for subdirs:
compiling: mk_obj_dir compile_dir

# This rule is explicitly selected on the command-line after processing the entire tree:
finish: $(BUILD)

mk_main_target_dirs: # Pre-create the output dirs, as MSVC can't be bothered...
	@if not exist "$(out_dir)" md "$(out_dir)"
	@if not exist "$(lib_dir)" md "$(lib_dir)"
	@if not exist "$(exe_dir)" md "$(exe_dir)"
#!!	@if not exist "$(cxx_mod_ifc_dir)" md "$(cxx_mod_ifc_dir)"

mk_obj_dir: # These vary for each subdir, so can't be done just once at init!
	@if not exist "$(obj_dir)" md "$(obj_dir)"

compile_mod_ifcs: mk_obj_dir $(OON_CPP_MODULE_IFCS)
#!! This doesn't have any modules-specific subdir (pre-creation) support yet,
#!! so actually setting the modules dirs to anything would fail the 1st time!
#!! (Even interface-only ones seem to generate .obj files, at least with MSVC!)

# The main workhorse rule...
#!! Albeit passing the targets on the cmd-line kill batch-mode inference rules in the child run,
#!! it might still be work around if the file set would be passed as a macro, and then a plain dep.
#!! rule using it could get inference working nominally again!...
!ifdef SRC_EXT_
compile_dir: $(OON_FULL_REBUILD_BY_MANUAL_DEPS) $(src_dir)\$(UNITS_PATTERN).$(SRC_EXT_)
!if "$(VERBOSE_CMD)" == "2"
	@$(ECHO) [[COMPILING *.$(SRC_EXT_) in """$(DIR)"""]: $(filterout $(UNITS_NO_COMPILE_PATTERN),$(patsubst $(src_dir)\\%,$(obj_dir)\\%, $(subst .$(SRC_EXT_),.obj,$**)))]]
!endif
	@$(MAKE_CMD) RECURSED_FOR_COMPILING=1 DIR=$(DIR) $(custom_build_options)\
		$(filterout $(UNITS_NO_COMPILE_PATTERN),$(patsubst $(src_dir)\\%,$(obj_dir)\\%, $(subst .$(SRC_EXT_),.obj,$**)))
!endif


obj_list_file=$(obj_dir)\obj.list
mainlib_rules_inc=$(out_dir)\main_lib_rules.inc
mainexe_rules_inc=$(out_dir)\main_exe_rules.inc

#!!DRY the duplicate scriptlets below!
_mainlibexe_rules_inc_cmd_body=^
	@echo off^
	set "_TAB_=	"^
        for %%x in ($(obj_source_exts)) do (^
		...^
	)^
	...^

!if "$(main_lib)" != ""
mk_mainlib_objdep_inc: mk_obj_dir
	@cmd /v:on /c <<$(out_dir)\mklibrules.cmd
	@echo off
        for %%x in ($(obj_source_exts)) do (
		set "_ext_=%%x"
		for /r "$(src_dir)\$(lib_src_subdir)" %%o in ($(UNITS_PATTERN).!_ext_!) do (
			set "_o_=%%o"
			echo !_o_! | findstr /R "$(UNITS_NO_LIB_PATTERN)" > nul
			if not errorlevel 1 (
				if "$(VERBOSE_CMD)" GEQ "1" echo - EXCLUDE FROM LIB: !_o_!
			) else (
				set "_o_=!_o_:$(src_dir_abspath)\=!"
				for %%x in ($(obj_source_exts)) do (
					set "_o_=!_o_:.%%x=.obj!"
				)
				set "objlist=!objlist! $(obj_dir)\!_o_!"
			)
		)
	)
	echo !objlist! > $(obj_list_file)
	set "_TAB_=	"
	echo $(main_lib): !objlist!               >  $(mainlib_rules_inc)
	rem echo %_TAB_%Creating lib: $$@...      >> $(mainlib_rules_inc)
	rem echo %_TAB_%lib -nologo -out:$$@ $$** >> $(mainlib_rules_inc)
<<keep
!else
mk_mainlib_objdep_inc:
!endif
!if "$(main_exe)" != ""
mk_mainexe_objdep_inc: mk_obj_dir
	@cmd /v:on /c <<$(out_dir)\mkexerules.cmd
	@echo off
        for %%x in ($(obj_source_exts)) do (
		set "_ext_=%%x"
		for /r "$(src_dir)\$(lib_src_subdir)" %%o in ($(UNITS_PATTERN).!_ext_!) do (
			set "_o_=%%o"
			echo !_o_! | findstr /R "$(UNITS_NO_AUTOLINK_PATTERN)" > nul
			if not errorlevel 1 (
				if "$(VERBOSE_CMD)" GEQ "1" echo - EXCLUDE FROM AUTO-LINK: !_o_!
			) else (
				set "_o_=!_o_:$(src_dir_abspath)\=!"
				for %%x in ($(obj_source_exts)) do (
					set "_o_=!_o_:.%%x=.obj!"
				)
				set "objlist=!objlist!$(obj_dir)\!_o_! "
			)
		)
	)
	echo !objlist! > $(obj_list_file)
	rem No use even for this as a deps hack, as it's included only in the post-dirwalk final round, with no proper comp. context:
	rem echo !objlist!: $(OBJ_DEPS_manually) ^>  $(mainexe_rules_inc)
	rem And this is bad, too, as by the time of linking there's no way back to seeing the whole tree and do inferencing...
	rem echo $(main_exe): !objlist! > $(mainexe_rules_inc)
	echo #!!  > $(mainexe_rules_inc)
	echo #!! Make a rule file with inference rules for each subdir instead!... >> $(mainexe_rules_inc)
	echo #!! >> $(mainexe_rules_inc)
<<keep
!else
mk_mainexe_objdep_inc:
!endif

clean:
# Cleans only the target tree of the current build alternative!
# And no way I'd just let loose a blanket RD /S /Q "$(out_dir)"!...
	@if not "$(abspath $(obj_dir))" == "$(abspath .\$(obj_dir))" echo - ERROR: Invalid object dir path: "$(obj_dir)" && exit -1
# Stop listing all the deleted .obj files despite /q -> cmd /e:off (self-explanatory, right?)
	@if exist "$(obj_dir)\*.obj" cmd /e:off /c del /s /q "$(obj_dir)\*.obj"
	@if exist "$(obj_list_file)" cmd /e:off /c del $(obj_list_file)
# To let the idiotic tools run at least, the dir must exist, so if it was deleted
# in a previous run, we must recreate it just to be able to check and then delete
# it right away again... Otherwise: "The system cannot find the file specified."):
	@if not exist "$(obj_dir)" mkdir "$(obj_dir)"
	@dir "$(obj_dir)" /s /b /a:-d 2>nul || rd /s /q "$(obj_dir)"
# Delete the main targets (lib/exe) separately, as they may be outside the tree:
	@for %f in ($(build)) do @if exist "%f" del "%f"
# Delete some other cruft, too:
	@del "$(out_dir)\*.pdb" "$(out_dir)\*.idb" "$(out_dir)\*.ilk" 2>nul
	@if exist "$(mainlib_rule_inc)" del "$(mainlib_rule_inc)"

clean_all:
	@if not "$(abspath $(out_dir))" == "$(abspath .\$(out_dir))" echo - ERROR: Invalid output dir path: "$(out_dir)" && exit -1
# RD will ask...:
# - But to let the idiotic tools run at least, the dir must exist, so if it was deleted
# in a previous run, we must recreate it just to be able to check and then delete it
# right away again... Otherwise: "The system cannot find the file specified."):
	@if not exist "$(out_dir)" mkdir "$(out_dir)"
	@if not "$(abspath $(out_dir))" == "$(abspath .)" @rd /s "$(out_dir)"
# Delete the libs/exes separately, as they may be off-tree:
	@if exist "$(main_lib)" del "$(main_lib)"
	@if exist "$(main_exe)" del "$(main_exe)"
#!!Still can't do the entire "matrix" tho! :-/ (Behold the freakish triple quotes here! ;) )
	@$(ECHO) - NOTE: Some build targets may still have been left around, if they are not in """$(out_dir)""".


#-----------------------------------------------------------------------------
# Actual ("low-level") build jobs...
#-----------------------------------------------------------------------------

# Dependency rules for the main lib/exe
## Sorry, no autodeps.; see at the compile_dir: rule!
### OON legacy: $(OBJS) $(CPP_MODULE_IFCS): $(INCLUDES) $(CPP_MODULE_SOURCES)


#------------------------
# Build the "main" lib
#------
!if "$(main_lib)" != ""
!ifdef RECURSED_FOR_FINISHING
!include $(mainlib_rules_inc)
!endif
#! Exploiting the fact that single-: rules are combined, so the deps. are in the include,
#! and the commands can be here, while still considering the dependencies:
$(main_lib):
	@$(ECHO) Creating lib: $@...
#!!Add VERBOSE support, but not with !if, but a $(mute)=@ cond. macro:
	lib -nologo -out:$@ $**
!endif

#------------------------
# Build the "main" exe
#------
!if "$(main_exe)" != ""
!ifdef RECURSED_FOR_FINISHING
!include $(mainexe_rules_inc)
!endif
#! See at main_lib: about implicitly combining the included deps.!
$(main_exe): $(obj_dir)\main.obj $(main_lib)
	@$(ECHO) Creating executable: $@...
#!!Add VERBOSE support, but not with !if, but a $(mute)=@ cond. macro:
	link -nologo $(LINKFLAGS) -out:$@ @$(obj_list_file) $(EXT_LIBS) $**
!endif

## Especially for this one...:
$(obj_dir)/main.obj: $(OON_HASH_INCLUDE_FILE)

!if defined(OON_HASH_INCLUDE_FILE)
$(OON_HASH_INCLUDE_FILE):
	$(ECHO) "	Make last commit ID available for #including..."
	$(BB) sh tooling/git/_create_commit_hash_include_file.sh
	$(ECHO)
!else
!message -ERROR: OON_HASH_INCLUDE_FILE not defined. Env setup not run?
!endif

#-----------------------------------------------------------------------------
# Some auto-remake support (-- the rest is in the OON build script!)
# Changing the makefile triggers a full rebuild.
#!! I'm sure there's a better way for this, but for now:
OON_FULL_REBUILD_BY_MANUAL_DEPS=$(OON_CPP_MODULE_IFCS)

#!ifdef SRC_EXT_
#!! I seriously don't understand why this nonsense is actually needed to trigger a full recomp.!
#!! It's adding /some of/ the /sources/ (of the current dir run) to the targets, right?! :-o
#!! Why is it even not a "dunno how to make" error?!
#OON_FULL_REBUILD_BY_MANUAL_DEPS=$(OON_FULL_REBUILD_BY_MANUAL_DEPS) $(src_dir)\$(UNITS_PATTERN).$(SRC_EXT_)
#!endif

$(OON_FULL_REBUILD_BY_MANUAL_DEPS): $(THIS_MAKEFILE)


#-----------------------------------------------------------------------------
fast_track_build: fast_track_compile fast_track_link

fast_track_compile:
# Emulating batch-mode inference rules...:
	$(_mute)$(CXX) $(CFLAGS) $(CXXFLAGS) -ifcOutput $(cxx_mod_ifc_dir)\ -Fo$(obj_dir)\ @$(SRCLIST_FILE)

fast_track_link: target.exe

target.exe:
#! See at main_lib: about implicitly combining the included deps.!
#$(main_exe): $(obj_dir)\main.obj $(main_lib)
	@$(ECHO) Creating executable: $@...
#!!Add VERBOSE support, but not with !if, but a $(mute)=@ cond. macro:
	link -nologo $(LINKFLAGS) -out:$@ @$(LINKER_OBJLIST_FILE) $(main_lib) $(EXT_LIBS)
